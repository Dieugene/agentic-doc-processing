# Архитектура системы агентного анализа больших документов

**Версия:** 2.1  
**Дата:** 2025-01-22  
**Статус:** Проект для перехода к реализации

---

## 1. Назначение и границы системы

### 1.1. Цели

Система предназначена для глубокого анализа больших документов (сотни страниц) с помощью ИИ-агентов. Ключевые задачи:

- Извлечение информации и ответы на вопросы по содержанию документа
- Анализ внутренних нестыковок в документе
- Сравнение с другими документами, включая выявление несоответствий нормативным требованиям
- Формализация регламентов (BPMN-диаграммы, правила в виде триггеров)

### 1.2. Типы анализируемых документов

- **Регуляторные документы** — Положения ЦБ, нормативные акты, методические указания. Характеристики: сотни страниц, сложная иерархическая нумерация (1.1.1.1), множество приложений, таблицы форм отчётности.
- **Отчёты эмитентов** — годовые отчёты, ESG-раскрытия, аудиторские заключения, проспекты эмиссии. Характеристики: финансовая отчётность в табличном виде, текстовые разделы с анализом, приложения.

### 1.3. Ключевые ограничения и приоритеты

| Параметр | Значение |
|----------|----------|
| Приоритет | Точность и непротиворечивость (не скорость) |
| Нагрузка | Малое количество пользователей (<100), высокая сложность документов |
| Время обработки | Не ограничено |
| Формат входа | PDF (включая сканы), Excel с несколькими листами |
| Модели агентов | Дешёвые модели (Claude Haiku, GPT-4o-mini, локальные) с SGR-структурированием |
| Модели парсинга | VLM + VLM-OCR для сканов (отдельный технический слой) |

### 1.4. Исключённые подходы

Система не использует:
- Наивное чанкование + векторные базы данных
- GraphRAG в смысле графов знаний (концептуальные сущности и отношения)
- Надежду на LLM с большим контекстным окном как основное решение

Допускается:
- "Граф документа" — структура из узлов (раздел, таблица, приложение) и связей между ними

---

## 2. Высокоуровневая архитектура

```
┌─────────────────────────────────────────────────────────────────────┐
│                         РАБОЧЕЕ ПРОСТРАНСТВО                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐           │
│  │ Документ 1  │     │ Документ 2  │     │ Документ N  │           │
│  ├─────────────┤     ├─────────────┤     ├─────────────┤           │
│  │  Скелет     │     │  Скелет     │     │  Скелет     │           │
│  │  Индекс     │     │  Индекс     │     │  Индекс     │           │
│  │  Снэпшоты   │     │  Снэпшоты   │     │  Снэпшоты   │           │
│  └─────────────┘     └─────────────┘     └─────────────┘           │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              Cross-Document Index + Shared Taxonomy          │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                           СЛОЙ АГЕНТОВ                              │
│  ┌──────────┐  ┌───────────┐  ┌─────────────┐  ┌────────────────┐  │
│  │Диспетчер │  │Индексатор │  │Нормализатор │  │Генератор       │  │
│  │          │  │           │  │             │  │снэпшотов       │  │
│  └────┬─────┘  └───────────┘  └─────────────┘  └────────────────┘  │
│       │                                                             │
│       │        ┌────────────────────────────────────────────┐      │
│       └───────►│          Снэпшот-агенты (по темам)         │      │
│                └────────────────────────────────────────────┘      │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                        ИНФРАСТРУКТУРНЫЙ СЛОЙ                        │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      LLM Gateway                             │   │
│  │              (централизованный доступ к моделям              │   │
│  │               с батчингом и rate limit control)              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. Архитектура данных

Система оперирует тремя слоями данных для каждого документа.

### 3.1. Слой 1: Структурный скелет (Document Skeleton)

**Назначение:** Физическое устройство документа в виде графа.

**Состав узла:**
```
Node {
  id: string                    // уникальный идентификатор
  type: enum                    // chapter | section | appendix | table | figure
  title: string                 // заголовок (если есть)
  content: string               // полный текст узла (включая подпункты)
  page_range: [start, end]      // страницы в исходном документе
  parent_id: string | null      // ссылка на родительский узел
  children_ids: string[]        // дочерние узлы (для навигации внутри)
  internal_structure: object    // иерархия подпунктов внутри узла
  explicit_refs: string[]       // явные ссылки ("см. п. 5.3", "Приложение Б")
  hash: string                  // хэш содержимого для отслеживания изменений
}
```

**Гранулярность узлов:**
- Узел = крупный раздел верхнего уровня (1., 2., 3., Приложение 1...)
- Внутренняя структура (1.1, 1.1.1) хранится внутри узла в поле `internal_structure`
- Типичный документ: десятки узлов (не сотни/тысячи)

**Когда строится:** Один раз при загрузке документа (Ingestion).

**Неизменяемость:** Текст внутри узлов не меняется после построения.

### 3.2. Слой 2: Навигационный индекс (Navigation Index)

**Назначение:** Связь между структурой документа и темами. Отвечает на вопрос "где про что написано".

**Структура:**

```
NavigationIndex {
  document_id: string
  taxonomy_version: string
  matrix: Map<node_id, Map<topic_id, Signal>>
}

Signal {
  relevance_score: float        // 0.0 - 1.0
  snippet: string               // краткое обоснование (почему узел относится к теме)
  sub_references: string[]      // ссылки на конкретные подпункты внутри узла
}
```

**Оси индекса:**
- **Y (структура):** Иерархия узлов скелета (Документ → Глава → Раздел)
- **X (таксономия):** Иерархическое дерево тем (например: Отчётность → Сроки → Ежемесячная)

**Когда строится:** При загрузке документа (после построения скелета).

### 3.3. Слой 3: Тематические снэпшоты (Snapshot-Agents)

**Назначение:** Готовые блоки знаний по конкретным темам. Каждый снэпшот — это агент с сохранённым состоянием.

**Структура снэпшота-агента:**

```
SnapshotAgent {
  id: string                    // "reporting_deadlines_doc714p"
  document_id: string
  topic_id: string
  
  // Конфигурация агента
  system_prompt: string         // роль, инструкции, ограничения
  
  // Накопленный контекст (развёрнутый текст, не структурированный JSON)
  context: {
    summary: string             // развёрнутый текст: что содержится по теме
    source_nodes: string[]      // узлы, на которых основан снэпшот
    scope_description: string   // явное описание границ
  }
  
  // Инструменты (набор tools определяется SGR-фреймворком)
  tools: [...]
  
  // Метаданные для инвалидации
  source_version: {
    document_hash: string
    nodes_hashes: Map<node_id, string>
    created_at: timestamp
  }
  
  // История диалогов (для многошагового общения)
  dialog_history: Message[]
  
  // Статус
  status: enum                  // active | stale
}
```

**Ключевое ограничение в system_prompt:**

> "Ты отвечаешь **только** на основе информации из указанных разделов документа: [перечень source_nodes]. Если информации недостаточно для ответа — прямо скажи об этом и предложи обратиться к другим разделам через tools. **Не дополняй, не интерпретируй и не выдумывай** сверх того, что явно написано в источнике."

**Стратегии генерации:**

| Стратегия | Когда применяется | Описание |
|-----------|-------------------|----------|
| **Eager** | При загрузке документа | Для ключевых тем из стартового набора |
| **Lazy** | При первом запросе | Снэпшот создаётся по запросу и сохраняется |

**Инвалидация:**
- При изменении хэша узла, на который опирается снэпшот → статус `stale`
- При обращении к `stale` снэпшоту: перегенерация или предупреждение пользователю

---

## 4. Таксономия тем

### 4.1. Источник таксономии

Таксономия формируется из самого документа с использованием двухпроходного подхода.

**Первый проход (Агент-Индексатор):**
- Читает каждый узел скелета
- Генерирует список "сырых" тем/тегов без нормализации
- Результат: набор тем с дубликатами и синонимами

**Второй проход (Агент-Нормализатор):**
- Получает все сырые темы
- Строит иерархическое дерево
- Объединяет синонимы
- Результат: нормализованная таксономия

### 4.2. Структура таксономии

```
Taxonomy {
  version: string
  root: TaxonomyNode
}

TaxonomyNode {
  id: string
  name: string                  // каноническое название
  aliases: string[]             // синонимы
  parent_id: string | null
  children_ids: string[]
}
```

### 4.3. Стартовый набор тем

Для типовых документов может задаваться предопределённый набор тем (Eager-генерация):

- **Положение ЦБ:** Требования к отчётности, Сроки представления, Формы документов, Ответственность, Исключения
- **Годовой отчёт эмитента:** Финансовые показатели, Риски, Корпоративное управление, Стратегия развития
- **ESG-отчёт:** Экологические риски, Социальная политика, Управление, Цели устойчивого развития

---

## 5. Обработка таблиц

### 5.1. Классификация таблиц

| Тип | Характеристика | Пример |
|-----|----------------|--------|
| **Тип А: Данные** | Числовые значения, поддаётся вычислениям | Баланс, отчёт о прибылях и убытках, график платежей |
| **Тип Б: Текстовые матрицы** | Текст в ячейках, сложная структура | Матрица ответственности, описание полномочий органов управления |

### 5.2. Обработка таблиц типа А (данные)

**Метод:** Code Interpreter (Python/Pandas/SQL)

- Таблица загружается в DataFrame или SQLite
- Агент генерирует код для извлечения/вычисления
- Исключаются галлюцинации LLM на арифметике

### 5.3. Обработка таблиц типа Б (текстовые матрицы)

**Метод:** Контекстуализация ячейки (Cell Flattening)

Преобразование таблицы в список утверждений:
```
[Заголовок строки] + [Заголовок столбца] → [Содержимое ячейки]
```

**Пример:**
```
Исходная таблица (из Положения о Совете директоров):
| Орган | Сделки до 1 млрд | Сделки свыше 1 млрд |
|-------|------------------|----------------------|
| Правление | Единолично | Совет директоров |

Результат флаттенинга:
- Орган "Правление" для "Сделки до 1 млрд": принимает решение единолично
- Орган "Правление" для "Сделки свыше 1 млрд": требуется одобрение Совета директоров
```

---

## 6. Базовый фреймворк агентов: SGR Agent Core

Все агенты системы построены на основе фреймворка **SGR (Schema-Guided Reasoning)**.

### 6.1. Репозитории

| Стек | Репозиторий |
|------|-------------|
| Python | https://github.com/vamplabAI/sgr-agent-core |
| TypeScript/JavaScript | https://github.com/vamplabAI/sgr-agent-core.js |

### 6.2. Почему SGR

- Позволяет использовать дешёвые модели (Claude Haiku, GPT-4o-mini, локальные) без потери качества
- Жёсткое структурирование через tools снижает галлюцинации
- Явная фиксация рассуждений обеспечивает прозрачность и отладку
- Контролируемый output через специализированные tools

### 6.3. Интеграция с системой

Все агенты системы (Диспетчер, Индексатор, Нормализатор, Генератор снэпшотов, Снэпшот-агенты) реализуются как SGR-агенты. Конкретный набор tools и конфигурация определяются в соответствии с документацией фреймворка.

**Документация:** https://vamplabai.github.io/sgr-agent-core/

---

## 7. LLM Gateway (централизованный доступ к моделям)

### 7.1. Назначение

При параллельной работе множества агентов (особенно на этапе индексации и Eager-генерации снэпшотов) возникает риск превышения rate limit API. **LLM Gateway** — централизованный модуль, через который проходят все запросы к LLM.

### 7.2. Архитектура

```
┌─────────────────────────────────────────────────────────────────┐
│                         LLM Gateway                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Request Queue                          │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │   │
│  │  │ Queue:      │  │ Queue:      │  │ Queue:      │       │   │
│  │  │ claude-haiku│  │ gpt-4o-mini │  │ local-llama │       │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘       │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Batch Executor                         │   │
│  │                                                           │   │
│  │  - Накапливает запросы в батч (по модели)                │   │
│  │  - Отправляет батч при достижении:                       │   │
│  │      • размера batch_size, или                           │   │
│  │      • таймаута batch_timeout                            │   │
│  │  - Пока батч выполняется — накапливает следующий         │   │
│  │  - Контролирует rate limit (RPM, TPM)                    │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Response Router                        │   │
│  │                                                           │   │
│  │  - Возвращает результаты вызывающим агентам              │   │
│  │  - Обрабатывает ошибки и retry                           │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3. Конфигурация

```
LLMGatewayConfig {
  models: {
    "claude-haiku": {
      endpoint: string
      api_key: string
      rate_limits: {
        rpm: number             // requests per minute
        tpm: number             // tokens per minute
      }
      batch_size: number        // макс. запросов в батче
      batch_timeout_ms: number  // таймаут накопления батча
    },
    ...
  }
  retry_policy: {
    max_retries: number
    backoff_multiplier: number
    initial_delay_ms: number
  }
}
```

### 7.4. Интерфейс для агентов

Агенты не обращаются к LLM напрямую. Вместо этого используют Gateway:

```python
response = await llm_gateway.request(
    model="claude-haiku",
    messages=[...],
    tools=[...],
    request_id="agent_123_step_5"  # для трейсинга
)
```

Gateway возвращает `Future`/`Promise`, агент может продолжить работу или ждать результата.

### 7.5. Логика батчинга

```
1. Агент A отправляет запрос → попадает в очередь claude-haiku
2. Агент B отправляет запрос → попадает в ту же очередь
3. ...накапливается до batch_size или batch_timeout
4. Batch Executor отправляет батч в API
5. Пока ждём ответа — накапливается следующий батч
6. Получаем ответы → Response Router раздаёт агентам
7. Следующий батч отправляется
```

### 7.6. Обработка rate limit

При получении 429 (rate limit exceeded):
1. Текущий батч помечается для retry
2. Gateway включает backoff (экспоненциальная задержка)
3. Новые запросы продолжают накапливаться в очереди
4. После backoff — retry + отправка накопленного

### 7.7. Приоритизация (опционально)

```
RequestPriority {
  HIGH   // запросы от пользователя (runtime)
  NORMAL // Eager-генерация снэпшотов
  LOW    // фоновая переиндексация
}
```

Запросы с высоким приоритетом обрабатываются первыми.

---

## 8. Агенты системы

### 8.1. Перечень агентов

| Агент | Когда работает | Входы | Выходы |
|-------|----------------|-------|--------|
| **Диспетчер** | При каждом запросе пользователя | Запрос пользователя | Ответ или передача диалога снэпшоту |
| **Индексатор** | При загрузке документа | Скелет документа | Навигационный индекс (сырые темы) |
| **Нормализатор** | После Индексатора | Сырые темы | Нормализованная таксономия |
| **Генератор снэпшотов** | Eager или первый Lazy-запрос | Тема + узлы из индекса | Снэпшот-агент |
| **Снэпшот-агент** | При запросе к теме | Вопрос пользователя | Ответ, запросы к другим агентам |

### 8.2. Агент-Диспетчер

**Роль:** Единая точка входа для всех запросов пользователя.

**Логика работы:**

```
1. Принять запрос пользователя
2. Классифицировать тип запроса:
   - Вопрос к документу → перейти к п.3
   - Команда на анализ → запустить соответствующий процесс
   - Мета-вопрос ("какие темы есть?") → обратиться к таксономии
3. Определить релевантные темы (обращение к индексу)
4. Проверить наличие снэпшотов по темам:
   - Есть активный → активировать снэпшот-агент
   - Есть stale → перегенерировать или предупредить
   - Нет → запустить Генератор снэпшотов
5. Передать запрос снэпшоту-агенту
6. Получить ответ и вернуть пользователю
```

### 8.3. Агент-Индексатор

**Роль:** Построение навигационного индекса при загрузке документа.

**Особенность:** Работает параллельно по узлам. Все запросы к LLM идут через Gateway.

```
Для каждого узла (параллельно):
    1. Отправить запрос в Gateway: "Определи темы этого текста"
    2. Получить список тем с relevance_score
    3. Записать в матрицу индекса
```

### 8.4. Генератор снэпшотов

**Роль:** Создание снэпшота-агента по заданной теме.

**Логика:**

```
1. Получить тему
2. Обратиться к Navigation Index → список релевантных узлов
3. Для каждого узла (параллельно через Gateway):
   - Загрузить контент
   - Извлечь факты, относящиеся к теме
4. Агрегировать результаты в summary
5. Сформировать system_prompt и context
6. Сохранить снэпшот
```

### 8.5. Снэпшот-агент

**Роль:** Ответы на вопросы по конкретной теме, ведение многошагового диалога.

**Возможности:**
- Отвечать на вопросы, опираясь на накопленный контекст
- Ходить по ссылкам внутри документа (tool: `get_linked_element`)
- Запрашивать информацию у других снэпшотов (tool: `ask_agent`)
- Обращаться к другим документам (tool: `ask_document`)

---

## 9. Мульти-документный сценарий

### 9.1. Структура рабочего пространства

```
Workspace {
  id: string
  documents: Map<doc_id, DocumentContext>
  cross_document_index: CrossDocumentIndex
  shared_taxonomy: Taxonomy
}

CrossDocumentIndex {
  taxonomy: Taxonomy                          // объединённая таксономия
  matrix: Map<topic_id, Map<doc_id, Signal>>  // где какая тема в каких документах
}
```

### 9.2. Логика работы

**При добавлении документа:**
1. Индексация документа (скелет + навигационный индекс)
2. Темы документа мэппятся на общую таксономию (или расширяют её)
3. Обновляется cross_document_index

**При кросс-документном запросе:**
```
Запрос: "Сравни требования к отчётности в Положении 714-П и Указании 123-У"

1. Диспетчер определяет тему: "требования к отчётности"
2. Cross-document index: тема есть в обоих документах
3. Активируются снэпшоты-агенты обоих документов
4. Каждый отвечает по своей части
5. Диспетчер сводит ответы
```

---

## 10. Обработка ссылок внутри документа

### 10.1. Типы ссылок

- Явные: "см. пункт 5.3", "в соответствии с Приложением Б"
- Неявные: "указанные выше требования", "в предыдущем разделе"

### 10.2. Резолвинг ссылок

**При построении скелета:**
- Парсер выявляет явные ссылки и записывает их в поле `explicit_refs` узла

**При работе снэпшота-агента:**
- Tool `get_linked_element(link_ref)` резолвит ссылку и возвращает контент или summary

---

## 11. Pipeline обработки документа

### 11.1. Этап 1: Загрузка (Ingestion)

```
Вход: PDF / Excel файл

1. Парсинг структуры (VLM + VLM-OCR для сканов)
2. Построение скелета
3. Теггирование служебных блоков ([category: toc], [category: boilerplate])

Выход: DocumentSkeleton
```

### 11.2. Этап 2: Индексация

```
Вход: DocumentSkeleton

1. Агент-Индексатор (параллельно по узлам, через Gateway)
2. Агент-Нормализатор

Выход: NavigationIndex, Taxonomy
```

### 11.3. Этап 3: Eager-генерация снэпшотов

```
Вход: NavigationIndex, Taxonomy, стартовый набор тем

Для каждой темы из набора (параллельно, через Gateway):
   Генератор снэпшотов → SnapshotAgent

Выход: Map<topic_id, SnapshotAgent>
```

### 11.4. Этап 4: Runtime (работа с запросами)

```
Вход: Запрос пользователя

1. Диспетчер классифицирует запрос
2. Определение тем через индекс
3. Проверка/создание снэпшотов
4. Активация снэпшота-агента
5. Диалог
6. Возврат ответа

Выход: Ответ пользователю
```

---

## 12. Нерешённые вопросы (TBD)

### 12.1. Выявление противоречий

Механика автоматического поиска нестыковок — требует отдельной проработки после накопления базы.

### 12.2. Инкрементальность снэпшотов

Как дополнительный анализ интегрируется с существующими снэпшотами.

### 12.3. Обработка неявных ссылок

"Указанные выше требования" — требует понимания контекста.

---

## 13. Глоссарий

| Термин | Определение |
|--------|-------------|
| **SGR (Schema-Guided Reasoning)** | Фреймворк для построения агентов с явным структурированием рассуждений |
| **LLM Gateway** | Централизованный модуль доступа к LLM с батчингом и rate limit control |
| **Скелет (Skeleton)** | Граф физической структуры документа (узлы = разделы) |
| **Навигационный индекс** | Матрица "узел × тема" с оценками релевантности |
| **Снэпшот-агент** | Агент с сохранённым контекстом по конкретной теме |
| **Таксономия** | Иерархическое дерево тем документа |
| **Eager-генерация** | Создание снэпшотов при загрузке (для ключевых тем) |
| **Lazy-генерация** | Создание снэпшота при первом запросе |
| **Cell Flattening** | Преобразование текстовой таблицы в список утверждений |
| **Диспетчер** | Центральный агент-маршрутизатор запросов |

---

## Приложение А: Примеры структур данных

### А.1. Узел скелета (Положение ЦБ)

```json
{
  "id": "section_3",
  "type": "chapter",
  "title": "3. Требования к отчётности",
  "content": "3. Требования к отчётности\n3.1. Кредитные организации представляют...",
  "page_range": [15, 42],
  "parent_id": "root",
  "children_ids": [],
  "internal_structure": {
    "3.1": {"title": "Общие требования", "page": 15},
    "3.2": {"title": "Сроки представления", "page": 18},
    "3.2.1": {"title": "Ежемесячная отчётность", "page": 18},
    "3.2.2": {"title": "Квартальная отчётность", "page": 20}
  },
  "explicit_refs": ["ref:appendix:1", "ref:appendix:2"],
  "hash": "a1b2c3d4e5f6"
}
```

### А.2. Запись навигационного индекса

```json
{
  "node_id": "section_3",
  "topic_id": "reporting_deadlines",
  "signal": {
    "relevance_score": 0.95,
    "snippet": "Основной раздел о сроках представления отчётности",
    "sub_references": ["3.2", "3.2.1", "3.2.2"]
  }
}
```

### А.3. Снэпшот-агент

```json
{
  "id": "reporting_deadlines_doc714p",
  "document_id": "doc714p",
  "topic_id": "reporting_deadlines",
  
  "system_prompt": "Ты эксперт по срокам представления отчётности согласно Положению 714-П. Ты отвечаешь ТОЛЬКО на основе информации из разделов 3, 3.2, 3.2.1, 3.2.2 и Приложения 1. Если информации недостаточно — скажи об этом. Не дополняй и не выдумывай.",
  
  "context": {
    "summary": "Положение 714-П устанавливает дифференцированные сроки представления отчётности в зависимости от типа отчёта и категории кредитной организации.\n\nЕжемесячная отчётность представляется не позднее 15-го числа месяца, следующего за отчётным. Квартальная отчётность — не позднее 30-го числа месяца, следующего за кварталом.\n\nДля системно значимых кредитных организаций сроки сокращены на 5 рабочих дней.",
    
    "source_nodes": ["section_3", "appendix_1"],
    
    "scope_description": "Информация извлечена только из раздела 3 и Приложения 1 Положения 714-П"
  },
  
  "tools": ["..."],
  
  "source_version": {
    "document_hash": "xyz789",
    "nodes_hashes": {
      "section_3": "a1b2c3d4e5f6",
      "appendix_1": "f6e5d4c3b2a1"
    },
    "created_at": "2025-01-22T10:00:00Z"
  },
  
  "dialog_history": [],
  "status": "active"
}
```

### А.4. Конфигурация LLM Gateway

```json
{
  "models": {
    "claude-haiku": {
      "endpoint": "https://api.anthropic.com/v1/messages",
      "rate_limits": {
        "rpm": 1000,
        "tpm": 100000
      },
      "batch_size": 10,
      "batch_timeout_ms": 100
    },
    "gpt-4o-mini": {
      "endpoint": "https://api.openai.com/v1/chat/completions",
      "rate_limits": {
        "rpm": 500,
        "tpm": 80000
      },
      "batch_size": 5,
      "batch_timeout_ms": 200
    }
  },
  "retry_policy": {
    "max_retries": 3,
    "backoff_multiplier": 2,
    "initial_delay_ms": 1000
  }
}
```
